// EXPERIMENTAL
// rough implementation of Damas-Hindley-Milner algorithm W and M

// Type aliasses
Variable :: String,
VariableType :: String,

// tagged unions
Expression :: (
    | Variable : Variable,
    | Abstraction : (var: Variable, abs: Expression), 
    | Application : (func: Expression, arg: Expression),
    | Let : (var: Variable, value: Expression, body: Expression),
)

// enum
FunctionType :: (
    | Arrow
    | Bool,
    | Int,
)

MonoType :: (
    | VariableType : VariableType,
    | ApplicationType : (fn_typ: FunctionType, args: [] MonoType),
)

PolyType :: (
    | MonoType : MonoType,
    | QuantifierType : (v_typ: VariableType, sigma: PolyType)
)

Context :: (
    // this is what I think a "map" could look like, basically a set with a mapping function 
    mappings : {} (Variable -> PolyType),

    // i'm still considering how/where "constuctors" should be declared
    // i'm leaning on having them inside the type declaration since they belong
    // only to this specific type
    // I also really like the "Self" keyword in Rust for complex types
    new : ([] (Variable, PolyType)) -> Context = (
        // "$" is a special word qualifier, for now it is used only to access local variables
        // the first "0" is to access the funcition's arguments, since it was unnamed
        // the second "0"/"1" is to access the arguments members by index, since it is a tuple
        Context (mappings := ($0.0 -> $0.1))
        // declaring and instantiating a struct differ slightly in syntax
        // note that the "mappings" member has a ":=" aka an instatiation
    )
)

// here are some helper functions for the DHM algorithm, basically:
// substitution -> apply + combine 
// new type variable
// instatiation
// generalise
// unify

// --- substitution -> apply + combine ---
Substitution :: {} (VariableType -> MonoType)

// another way to add constructors
// I like this better for type aliases 
// we are saying that a substitution is a mapping between variable types and monotypes
// and we also provide a constructor
Substitution.new :: ([] (Variable, PolyType)) -> Substitution = (Context (mappings := ($0.0 -> $0.1)))

Substitution. :: (value : Context | PolyType | Substitution) = (
    match value (
        c : Context -> c.map( (k, v) -> (k, self.(v)) ), // recursive calls
        // you can deconstruct the PolyType type
        v : VariableType -> self.get(v).else(value),
        // partial deconstruction and partial construction
        a : ApplicationType(args, ...) -> ApplicationType(args.map(arg -> self.(arg)), ...a),
        q : QuantifierType(sigma, ...) -> QuantifierType(self.(sigma), ...q),
        // take the value substitution and apply the self substitution
        // any value that hasn't been modified, use the contect in self
        s : Substitution -> Substitution({ value.map( (v, k) -> (v, self.(k)) ), ...self })
    )
)
// --- ---

// --- new type variable ---
VariableType.new :: ()
// --- ---


